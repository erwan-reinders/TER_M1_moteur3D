<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <script type="text/javascript" src="lib/gl-matrix-min.js" ></script>
    <script type="text/javascript" src="data/meshes/basic-object-models-IFS.js" ></script>
    <script type="text/javascript" src="data/meshes/teapot-model-IFS.js" ></script>

    <script type="text/javascript" src="js/util.js" ></script>
    <script type="text/javascript" src="js/framebuffer.js" ></script>
    <script type="text/javascript" src="js/texture.js" ></script>
    <script type="text/javascript" src="js/model.js" ></script>
    <script type="text/javascript" src="js/camera.js" ></script>
    <script type="text/javascript" src="js/Light.js" ></script>
    <script type="text/javascript" src="js/scene.js"></script>
    <script type="text/javascript" src="js/controller.js"></script>
    <script type="text/javascript" src="js/shaderProgram.js"></script>

</head>
<body>
    <div id="canvas-holder">
        <canvas width=1200 height=600 id="webglcanvas" style="background-color:white"></canvas>
    </div>

    <script type="text/javascript" defer>
        let shaders;

        let scene;

        function init(){
            message.informative("INITIALISATION", "initialisation of the scene");
            initGl("webglcanvas");
            
            shaders = new Map();

            //BLINN PHONG
            let s = new ShaderProgram("MVPVertexShader.glsl", "BlinnPhongFragmentShader.glsl");
            s.use();
            // uniform for vertex shader
            s.setUniform("uModelMatrix",      valType.Mat4fv);
            s.setUniform("uViewMatrix",       valType.Mat4fv);
            s.setUniform("uProjectionMatrix", valType.Mat4fv);
            s.setUniform("uNormalMatrix",     valType.Mat4fv);

            // uniform for fragment shader
            s.setUniform("uViewPos",    valType.f3v);
            s.setUniform("uLightPos",   valType.f3v);
            s.setUniform("uLightColor", valType.f3v);

            s.setUniform("uObjectColor", valType.f3v);
            s.setUniform("uShininess",   valType.f1);

            s.setAllPos();

            s.setBeforeRenderFunction(function (model, scene) {
                this.use();
                //Pour le vertex shader
                this.setUniformValueByName("uProjectionMatrix", scene.matrix.projectionMatrix);
                this.setUniformValueByName("uViewMatrix",       scene.matrix.viewMatrix);
                this.setUniformValueByName("uNormalMatrix",     scene.matrix.normalMatrix);

                this.setUniformValueByName("uModelMatrix", model.matrix.modelMatrix);

                this.setUniformValueByName("uViewPos",    scene.current_camera.position);
                this.setUniformValueByName("uLightPos",   scene.current_light.position);
                this.setUniformValueByName("uLightColor", scene.current_light.color);
                
                this.setUniformValueByName("uObjectColor", vec3.clone([1.0, 0.0, 1.0]));
                this.setUniformValueByName("uShininess",   16.0);
            });

            shaders.set("blinnPhong", s);

            //TEXTURE
            s = new ShaderProgram("MVPVertexShader.glsl", "TextureBrutFragmentShader.glsl");
            s.use();
            // uniform for vertex shader
            s.setUniform("uModelMatrix",      valType.Mat4fv);
            s.setUniform("uViewMatrix",       valType.Mat4fv);
            s.setUniform("uProjectionMatrix", valType.Mat4fv);
            s.setUniform("uNormalMatrix",     valType.Mat4fv);

            // uniform for fragment shader
            s.setUniform("uSampler",   valType.i1);

            s.setAllPos();

            s.setBeforeRenderFunction(function (model, scene) {
                this.use();
                //Pour le vertex shader
                this.setUniformValueByName("uProjectionMatrix", scene.matrix.projectionMatrix);
                this.setUniformValueByName("uViewMatrix",       scene.matrix.viewMatrix);
                this.setUniformValueByName("uNormalMatrix",     scene.matrix.normalMatrix);

                this.setUniformValueByName("uModelMatrix", model.matrix.modelMatrix);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, model.texture);
                this.setUniformValueByName("uSampler", 0);
            });

            shaders.set("texture", s);

            
            //GBUFFER
            s = new ShaderProgram("MVPVertexShader.glsl", "GBufferBasicFragmentShader.glsl");
            s.use();
            // uniform for vertex shader
            s.setUniform("uModelMatrix",      valType.Mat4fv);
            s.setUniform("uViewMatrix",       valType.Mat4fv);
            s.setUniform("uProjectionMatrix", valType.Mat4fv);
            s.setUniform("uNormalMatrix",     valType.Mat4fv);

            // uniform for fragment shader
            s.setUniform("uObjectColor",    valType.f3v);
            s.setUniform("uObjectSpecular", valType.f1);

            s.setAllPos();

            s.framebuffer = new Framebuffer(canvas.width, canvas.height, 3);
            s.setBeforeAnyRendering(function () {
                this.framebuffer.use();
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                Framebuffer.clear();
            });
            s.setBeforeRenderFunction(function (model, scene) {
                this.use();
                //Pour le vertex shader
                this.setUniformValueByName("uProjectionMatrix", scene.matrix.projectionMatrix);
                this.setUniformValueByName("uViewMatrix",       scene.matrix.viewMatrix);
                this.setUniformValueByName("uNormalMatrix",     scene.matrix.normalMatrix);

                this.setUniformValueByName("uModelMatrix", model.matrix.modelMatrix);
                
                this.framebuffer.use();

                let color = (model.color) ? model.color : vec3.clone([0.0, 1.0, 1.0]);
                let spec = (model.spec) ? model.spec : 1.0;
                this.setUniformValueByName("uObjectColor",    color);
                this.setUniformValueByName("uObjectSpecular", spec);
            });
            s.setAfterRenderFunction(function (model, scene) {
                Framebuffer.clear();
            });

            shaders.set("basicGBuffer", s);


            //LIGHTING
            s = new ShaderProgram("ScreenPosVertexShader.glsl", "GBufferTestLightFragmentShader.glsl");
            s.use();

            s.setUniform("gPosition",   valType.i1);
            s.setUniform("gNormal",     valType.i1);
            s.setUniform("gAlbedoSpec", valType.i1);

            s.setAllPos();

            s.setBeforeRenderFunction(function (model, scene) {
                this.setUniformValueByName("gPosition", 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, shaders.get("basicGBuffer").framebuffer.textures[0]);

                this.setUniformValueByName("gNormal", 1);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, shaders.get("basicGBuffer").framebuffer.textures[1]);

                this.setUniformValueByName("gAlbedoSpec", 2);
                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_2D, shaders.get("basicGBuffer").framebuffer.textures[2]);
            });

            shaders.set("testGBufferLight", s);



            s = new ShaderProgram("ScreenPosVertexShader.glsl", "LightBlinnPhongFragmentShader.glsl");
            s.use();

            s.setUniform("gPosition",   valType.i1);
            s.setUniform("gNormal",     valType.i1);
            s.setUniform("gAlbedoSpec", valType.i1);

            s.setUniform("uViewPos",    valType.f3v);

            s.setAllPos();

            s.setBeforeRenderFunction(function (model, scene) {
                this.setUniformValueByName("gPosition", 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, shaders.get("basicGBuffer").framebuffer.textures[0]);

                this.setUniformValueByName("gNormal", 1);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, shaders.get("basicGBuffer").framebuffer.textures[1]);

                this.setUniformValueByName("gAlbedoSpec", 2);
                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_2D, shaders.get("basicGBuffer").framebuffer.textures[2]);
                
                this.setUniformValueByName("uViewPos",    scene.current_camera.position);
            });

            shaders.set("lightBlinnPhong", s);

        }

        let controler;
        function main() {
            init();
            scene = new Scene("webglcanvas");

            let m;

            //BRONZE
            m = new Model(cube(), "basicGBuffer");
            m.matrix.modelMatrix = mat4.clone(
                [1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                -2, 0, 0, 1]
            )
            m.color = vec3.clone([0.86, 0.61, 0.23]);
            m.spec = 10.0;
            scene.addModel(m);

            //SILVER
            m = new Model(cube(), "basicGBuffer");
            m.matrix.modelMatrix = mat4.clone(
                [1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1]
            )
            m.color = vec3.clone([0.66, 0.61, 0.63]);
            m.spec = 30.0;
            scene.addModel(m);

            
            //GOLD
            m = new Model(cube(), "basicGBuffer");
            m.matrix.modelMatrix = mat4.clone(
                [1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                2, 0, 0, 1]
            )
            m.color = vec3.clone([0.96, 0.91, 0.23]);
            m.spec = 100.0;
            scene.addModel(m);


            m = new Model(cube(), "basicGBuffer");
            m.matrix.modelMatrix = mat4.clone(
                [100, 0, 0, 0,
                0, 0.01, 0, 0,
                0, 0, 100, 0,
                0, -1, 0, 1]
            )
            scene.addModel(m);

            scene.addModel(new Model(quad(), "lightBlinnPhong"));
            
            scene.initModels();

            controler = new Controller(scene);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);

            frame();
        }

        function onKeyDown(event) {
            controler.onKeyDown(event);
        }
        function onKeyUp(event) {
            controler.onKeyUp(event);
        }
        function onMouseMove(event) {
            controler.onMouseMove(event);
        }
        function onMouseDown(event) {
            controler.onMouseDown(event);
        }
        function onMouseUp(event) {
            controler.onMouseUp(event);
        }

        function frame() {
            controler.processInput();
            scene.render();
            requestAnimationFrame(frame);
        }

        window.onload = main;
    </script>
</body>
</html>